#!/usr/bin/env node

/* eslint no-param-reassign: 0 */

const { join } = require('path');
const { pipe, through } = require('mississippi');

const _ = require('lodash');
const { sync: rimrafSync } = require('rimraf');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const dbsParentDir = join(__dirname, '../../data/leveldb/');
const JSON_ENC = { valueEncoding: 'json' };

const SHST_GEOMETRY_DIR = join(dbsParentDir, 'shstGeometry');
const SHST_METADATA_DIR = join(dbsParentDir, 'shstMetadata');

const SHST_COORDS_TO_NODES_DIR = join(dbsParentDir, 'shstCoordsToNodes');
const SHST_NODES_TO_REFS_DIR = join(dbsParentDir, 'shstNodesToRefs');

rimrafSync(SHST_COORDS_TO_NODES_DIR);
rimrafSync(SHST_NODES_TO_REFS_DIR);

const shstGeometryDB = levelup(encode(leveldown(SHST_GEOMETRY_DIR), JSON_ENC));
const shstMetadataDB = levelup(encode(leveldown(SHST_METADATA_DIR), JSON_ENC));

const shstCoordsToNodesDB = levelup(
  encode(leveldown(SHST_COORDS_TO_NODES_DIR), JSON_ENC)
);

const shstNodesToRefsDB = levelup(
  encode(leveldown(SHST_NODES_TO_REFS_DIR), JSON_ENC)
);

pipe(
  shstReferenceDB.createReadStream(),
  through.obj(async function collectRefMetadata(
    { key: shstRefId, value: shstRefMeta },
    $,
    cb
  ) {
    const shstGeomIds = _(shstRefMeta)
      .map('geometryId')
      .flatten()
      .filter(_.negate(_.isNil))
      .uniq()
      .value();

    const shstGeomMeta = await Promise.all(
      shstGeomIds.map(async shstGeomId => {
        try {
          // Get this node's ways info object if it exists.
          const d = await shstGeometryDB.get(shstGeomId);

          return d;
        } catch (err) {
          console.warn(
            JSON.stringify({
              level: 'warn',
              msg: 'No shstIntersection metadata found',
              shstRefId,
              shstGeomId
            })
          );

          return null;
        }
      })
    );

    const shstGeomMetaById = shstGeomMeta.reduce((acc, d) => {
      if (!d) {
        return acc;
      }

      const {
        properties: { id }
      } = d;

      acc[id] = d;

      return acc;
    }, {});

    const shstGeomOsmMeta = await Promise.all(
      Object.keys(shstGeomMetaById).map(async shstGeomId => {
        try {
          // Get this node's ways info object if it exists.
          return await shstMetadataDB.get(shstGeomId);
        } catch (err) {
          console.warn(
            JSON.stringify({
              level: 'warn',
              msg: 'No OSM metadata found for geometry',
              shstRefId,
              shstGeomId
            })
          );

          return null;
        }
      })
    );

    const shstGeomOsmMetaByGeomId = shstGeomOsmMeta.reduce((acc, d) => {
      if (d === null) {
        return acc;
      }

      const { geometryId, osmMetadata } = d;
      acc[geometryId] = osmMetadata;
      return acc;
    }, {});

    const shstIntxnIds = _(shstRefMeta.locationReferences)
      .map('intersectionId')
      .filter(_.negate(_.isNil))
      .uniq()
      .value();

    const shstIntxnMeta = await Promise.all(
      shstIntxnIds.map(async shstIntxnId => {
        try {
          // Get this node's ways info object if it exists.
          const d = await shstIntersectionDB.get(shstIntxnId);

          return d;
        } catch (err) {
          console.warn(
            JSON.stringify({
              level: 'warn',
              msg: 'No shstIntersection metadata found',
              shstRefId,
              shstIntxnId
            })
          );

          return null;
        }
      })
    );

    await shstReferenceMetadataJoinDB.put(shstRefId, {
      shstRefId,
      shstRefMeta,
      shstGeomMeta: shstGeomMetaById,
      shstGeomOsmMeta: shstGeomOsmMetaByGeomId,
      shstIntersectionMeta: shstIntxnMeta.filter(d => d !== null)
    });

    return cb();
  }),
  err => {
    if (err) {
      console.error(err);
    }
  }
);
